# 2. 리눅스 시스템의 이해

## 2-3. X 윈도우

### 2-3-1. X 윈도우의 개념

1. X 윈도우의 정의
   1. X프로토콜을 통해 디스플레이 장치에 윈도우를 그려주는 유닉스 및 리눅스의 윈도우 시스템
2. 역사
   1. 1984년, IBM, MIT, DEC 아데나 프로젝트(Athena Project)를 통해 밥 쉐이플러(Bob Scheifler)와 짐 게티스(Jim Gettys) 개발
   2. 1986년, 밥 쉐이플러가 오픈소스화 하기 위한 디자인 수행
   3. 1987년, 오픈소스 프로젝트하 X11 발표
   4. 1988년, X 컨소시엄이 조직, X11R2 발표
   5. 1996년, X 컨소시엄 해체
   6. 1996년, 공개 배포 라이선스 무시 XFree86 같은 프로젝트 등장, 새로운 라이선스 정책 문제
   7. 1999년, 오픈 그룹이 X.org 만들고 X11R6.5.1 발표
   8. 2019년, X11R7.8 개별 컴포넌트의 개발 완료
3. 특징
   1. 윈도우(Windows)는 커널과 윈도우가 하나의 통으로 이루어 졌다면, 리눅스(Linux)는 커널과 X 윈도우 시스템 분리 가능해 따로 설치 가능
   2. X 프로토콜이라 불리는 네크워크 프로토콜을 사용
   3. 클라이언트 서버 모델(Client Server Model)을 사용, 서버는 사용자, 클라이언트는 응용 프로그램
   4. 네트워크로 연결될 수 있다면 X 윈도우를 이용 가능
   5. X 클라이언트는 원격지의 X 서버 시스템에 동작하는 응용 프로그램 실행 가능
   6. X 윈도우는 사용자 인터페이스에 독립적, 즉 KDE, GNOME, XFCE 등의 데스크톱환경은 X 윈도우 환경에서 구현된 X 클라이언트일 뿐
   7. 서버 클라이언트 모델을 사용하므로 이론적으로 X 프로토콜만 준수한다면 어떤 시스템이든 쉽게 X 윈도우에 이식 가능

### 2-3-2. X 윈도우의 구조

1. X 서버
   1. 디바이스 관리, 디스플레이 장치 제어 X 클라이언트에게 디스플레이 서비스 제공
   2. X 서버는 로컬의 X 클라이언트와의 통신을 위해 `/tmp/.X11-unix/X0` 라는 유닉스 도메인 소캣(Unix Domain Socket)을 사용
   3. X 서버는 원격지의 X 클라이언트와의 통신을 위해 TCP 포트 6000 을 사용
   4. 로컬 및 원격지의 다수가 X 클라이언트 연결을 허용
   5. 대표적 오픈소스 프로젝트로는 XFree86, X.org가 있음
2. X 클라이언트
   1. 
3. X 프로토콜
4. Xlib/XCB
5. XToolkit

### 2-3-3. XFree86과 X.org

1. XFree86
2. X.org

### 2-3-4. X 윈도우의 계층

1. 디스플레이 매니저
   1. ~

2. 세션(X session)
   1. ~

3. 윈도우 매니저(Window Manager)
   1. ~

4. 데스크톱환경(Desktop Environment)
   1. ~

### 2-3-5. 데스크톱환경 구성 사례

1. KDE의 구성
   1. 1996년, 마티아스 에트리히(Matthias Ettrich)가 Qt 라이브러리 기반 데스크톱환경 개발 시작
   2. Qt 라이브러리가 라이선스 사용x, 걱정하는 개발자들은 GNOME 프로젝트를 시작
   3. 1998년, Qt 라이브러리는 QPL 라이선스를 채용, GPL과 호환성 논의 계속
   4. 2000년, Qt 라이브러리의 유닉스용은 GPL로 공개
   5. Qt4.0부터 지원, Linux 뿐만 아니라 FreeBSD, Solaris, macOS, Windows 플랫폼 모두 지원
   6. 디스플레이 매니저: KDM(Qt, Xlib), 파일 관리자: Konqueror, 윈도우 매니저: Kwin(KWN)

1. GNOME(GNU Network Object Model Environment)의 구성
   1. GNU에서 개발한 공개형 데스크톱환경
   2. GPL 라이선스가 아닌 Qt 라이브러리를 사용하였던 KDE의 대안으로 개발
   3. GNOME은 LGPL 라이선스를 갖는 GTK+ 라이브러리 사용, LGPL 라이선스기 때문에 GNOME 용 응용 프로그램이 개발
   4. 디스플레이 매니저: GDM, 파일관리자: nautilus, 윈도우 매니저는 GNOME2: Metacity, GNOME3: Mutter 사용

### 2-3-6. X 윈도우 실행

1. 시스템 시작 시 X 윈도우 실행하기
   1. `/etc/initab` 파일을 root 권한으로 열어 init 프로세스 실행 레벨을 5로 변경
   2. `/etc/initab` 파일을 저장, reboot 명령을 사용해 시스템 재부팅 시 X 윈도우가 자동으로 실행

2. 터미널에서 X 윈도우 실행하기
   1. 실행 레벨이 3으로 설정되어 있으면 터미널 모드로 부팅
   2. userid, password 를 입력
   3. 로그인 완료시 `startx` 명령어로 X 윈도우 실행
   4. `startx` 명령어는 `--` 인자값(argument)를 전달 가능
      - `startx --depth 16`: 하이컬러 모드로 X 윈도우 실행
      - `startx -- :1`: 두 번째 윈도우 터미널에 X 윈도우 실행

3. 원격지에서 X 윈도우 실행하기
   1. xhost 명령어
      - xhost를 통하여 X 서버에 접근할 수 있는 클라이언트를 지정, 해제 가능
      - 사용 형식
        - `xhost [+|-] [address|hostname]`
        - `xhost`: 현재 설정된 접근 목록 출력
        - `xhost +`: 모든 클라이언트의 접속 허용
        - `xhost -`: 모든 클라이언트의 접속 차단
        - `xhost - 192.168.100.39`: 특정 IP 접속을 차단
   2. DISPALY 환경변수
      - X 클라이언트 프로그램이 윈도우를 표시할 서버의 주소를 설정하는 환경변수
      - `:0.0`은 기본값, 현재 시스템의 첫 번째 X 윈도우의 첫 번째 모니터를 뜻함
      - `export DISPALY="192.168.100.41:0.0"`: X 클라이언트 프로그램의 화면 출력을 특정 IP로 보냄
      - `export DISPALY="192.168.100.41:0.1"`: 위의 2번째 모니터로 보냄
   3. xauth
      - `.Xauthority` 파일에 쿠키 내용을 추가, 삭제, 리스트 출력하는 유틸리티
      - `xauth list`: 설정값 보기, `xauth add`: 설정값 추가
      - xhost가 호스트 기반 인증 방식, xauth는 MMC(MIT Magic Cookie) 기반의 인증 방식
      - MMC: 서버를 시작시 매직 쿠키 생성, 서버로 패킷 전송 시 매직 쿠기 포함, 매직 쿠키가 동일 시 접속 승인

### 2-3-7. X 윈도우 응용 프로그램

1. 이미지 편집
   1. GIMP(GNU Image Manipulation Program)
   2. ImageMagick
   3. Eog(Eye of GNOME)
   4. kdegraphics
2. 미디어 재생기
   1. Totem
   2. KMid
3. 음악재생
   1. Rhythmbox
4. 문서 관리
   1. evince
   2. LibreOffice

## 2-4. 셸(Shell)

### 2-4-1. 셸의 이해

1. 셸의 개념
   1. 일반적인 셸의 정의
      - 사용자가 커널의 서비스 기능 사용하게 하는 통로, 인터페이스
      - CLI(Command-Line Interface), GUI(Graphical User Interface)로 나뉨
      - 리눅스의 셸: 일반적으로 CLI 방식을 의미
   2. 리숙스 셸의 역사
      - 1971: 최초의 유닉스 셸, 톰프슨 셸(Thompson shell)
      - 1977: 유닉스의 본셸(Bourne shell)
      - 1970후반: C셸
      - 1983: C셸 기능들 + 본셸 하위호환 -> 콘셸(Korn shell)
      - 특허 없는 셸 추구 -> 본셸 개선 -> bash셸(Bourne Again Shell)
   3. 리눅스 셸의 특징
      - 명령어 입력, 해석, 내장 및 외장 명령어를 처리하는 대화형 사용자 인터페이스
      - 직접 커널의 명령이 어려워 셸을 통해 쉽게 관리 가능
      - 파일 관리, 프로세스 관리, 배치 프로세싱, 성능 모니터링, 환경 설정 등 관리
      - 커널이 제공하는 시스템 콜을 통해 구현(일반 응용 프로그램과 같음), 커널에 쉽게 명령이 목적

2. 셸의 유형
   1. 본셸 계열
      - sh(bourne shell): 스티븐 본 계발, 유닉스 기본 셸이였음
      - ksh(korn shell): 본셸과 호환, history, alias기능, 작업 제어 기능, 명령행 편집 기능
      - bash(bourne again shell): 리눅스에서 가장 많이 사용, GPLv3, 다양한 운영체제 이식가능, ksh, csh 영향, 명령 히스토리, 디렉터리 스택, 명령어 치환, 명령어 자동완성 기능 등 제공
   2. C셸 계열
      - csh(C shell): C언어를 기반, 강력한 프로그래밍 기능 제공, 히스토리, 별명, 작업 제어 등 제공
      - tcsh(TC shell): 명령줄 완성 기능, 명령줄 편집 기능 영향, csh과 호환

3. 셸의 설정 및 확인
   1. 현재 셸의 확인
      - `환경변수 SHELL`: 현재 로그인한 사용자의 셸을 확인
        ```bash
        $ echo $SHELL  # /bin/bash
        ```
   2. 시스템이 지원하는 셸 목록 확인-1
      - `chsh -l`: 시스템이 지원하는 셸 목록 확인
        ```bash
        $ chsh -l  # 지원 셸 목록들 출력
        ```
   3. 시스템이 지원하는 셸 목록 확인-2
      - `/etc/shells`: 목록 기록되어 있음
        ```bash
        $ cat /etc/shells
        ```
   4. 셸의 변경
      - `chsh -s`: 셸 변
        ```bash
        $ chsh -s /bin/csh  # csh로 변경, 패스워드 입력해야 함
        ```
   5. 특정 사용자의 셸 확인
      - /etc/passwd francis가 사용하는 셸 찾기
        ```bash
        $ cat /etc/passwd | grep francis  # 마지막쯤에 ~/bin/csh로 확인
        ```
   6. 환경변수를 통한 설정 확인
      - 시스템 정보
        - `HOSTNAME`: 시스템 호스트명
        - `OSTYPE`: 실행 중인 시스템의 운영체제 유형에 대한 정보
        - `DISPLAY`: X 윈도우 트래피을 처리할 X 디스플레이 서버의 위치
        - `PATH`: 실행 파일이 위치한 디렉터리의 집합
        - `LANG`: 셸 사용 시 기본으로 지원되는 언어
      - 셸 정보
        - `PS1`: PS는 Prompt Statement or Pri=ompt String의 약자, 기본 프롬프트 표시명
        - `PS2`: PS는 하나의 명령어를 여러 줄로 입력할 때 표시하는 프롬프트 표시명
        - `SHELL`: 로그인한 사용자의 셸을 보여줌
        - `HISTFILE`: history 정보가 저장되어 있는 파일 경로
        - `HISTFILESIZE`: history 파일의 크기
        - `HISSIZE`: history 파일 명령어 갯수
      - 사용자
        - `UID`: 로그인한 사용자의 UID
        - `USER`: 로그인한 사용자의 계정명
        - `HOME`: 로그인한 사용자의 홈 디렉터리
        - `PWD`: 로그인한 사용자 현재 작업 디렉터리의 경로
      - 응용 프로그램
        - `TERM`: 로그인한 사용자의 터미널 종류
        - `MAIL`: 수신한 메일 저장된 경로
   7. 환경변수를 통한 환경 설정 예제

4. 셸의 시작과 종료
   1. 로그인 셸과 비로그인 셸
   2. 인터랙티브 셸과 비인터랙티브 셸
   3. 리눅스 셸의 시작
   4. 리눅스 셸의 종료
   5. 리눅스 셸의 설정 파일

5. 셸의 기능
   1. 자동완성(bash-completion)
   2. 히스토리(history)
   3. alias
   4. 키보드 단축키
   5. 명령어 치환(Command substitution)
   6. 표준 입출력
   7. 리다이렉션
   8. 파이프
   9. 그룹 명령
   10. 작업 제어(Job Control Command)
   11. 산술 논리 연산
   12. 프롬프트 제어 기능
   13. 확장된 내부 명령어

6. 셸과 메타문자

### 2-4-2. 셸 프로그래밍

1. 셸 프로그래밍의 개요
   1. 셸 프로그래밍의 개념
   2. 형식
   3. 실행

2. 셸 스크립트의 기본 문법
   1. 주석
   2. 변수
   3. 위치매개변수
   4. echo문
   5. 다양한 조건식

3. 셸 스크립트의 조건문
   1. if문
   2. case문

4. 셸 스크립트의 반복문
   1. for문
   2. while문
   3. until문
   4. select문

5. 셸 스크립트의 함수
   1. 함수 구문 문법

6. 셸 스크립트의 부분 문자열 제거(Substring removal)
   1. 스트링과 패턴을 비교, 문자열을 소거하는 4가지 방법

## 2-5. 프로세스

### 2-5-1. 프로세스 개요

1. 프로세스의 개념
   1. 정의
   2. 특징

2. 프로세스의 유형
   1. Init 프로세스
   2. 부모 프로세스와 자식 프로세스
   3. 고아 프로세스와 좀비 프로세스
   4. 데몬

3. 프로세스와 식별자
   1. PID(Process Identifier)
   2. PPID(Parent Process Identifier)
   3. UID(User Identifier) or GID(Group Identifier)

### 2-5-2. 프로세스 동작 원리

1. 프로세스 생성하기
   1. exec 방식
   2. fork 방식
   3. fork()와 exec()를 통한 프로세스 생성 과정

2. 프로세스 제어하기
   1. Foreground processes
   2. Background processes
   3. 포어와 백 전환하기
   4. 우선순위의 설정

3. 프로세스 중지하기
   1. 키모드 단축키
   2. kill 명령어 사용

4. 프로세스 상태
5. 프로세스 구조
   1. PCB(Process Control Block)
   2. 프로세스 테이블(Process Table)

### 2-5-3. 데몬

1. 데몬의 실행 방식
   1. standalone 방식
   2. xinetd 방식(eXtended InterNET)

2. 데몬 시작하기
   1. /etc/rc.d/init.d를 통한 데몬 시작하기
   2. init 프로세스 실행레벨에 따른 데몬 시작하기

3. 데몬 실행 설정 도구
   1. ntsysv
   2. chkconfig
   3. system-config-services
