# 2. 리눅스 시스템의 이해

## 2-1. 리눅스와 하드웨어

### 2-1-1. 하드웨어의 이해

1. 하드웨어의 이해
   1. 컴퓨터의 구성 요소
      1. 중앙처리장치
         - 외부에서 정보를 입력 받아 명령어 해석, 연산, 결과 반환, 컴퓨터 제어장치
         - CPU는 레지스터(Register)와 연상장치(ALU: Arithmetic-Logic Unit), 제어장치(Control Unit)
           - 레지스터: CPU가 연산을 처리하기 위한 임시 저장소 역할, 작은 데이터만을 저장할 수 있음, 액세스 속도가 빠르다
           - 연산장치: 데이터들 간 비교, 판단, 연산 수행
           - 제어장치: 명령어 해석, 해석한 명령을 연산장치 등으로 보내고 주소를 디코드하여 레지스터에 데이터를 저장
      2. 주기억장치
         - CPU가 처리할 명령어와 데이터를 저장하기 위한 컴퓨터 하드웨어 장치
         - RAM(Random Access Memory): 휘발성 메모리
           - 전원 공급 중단시 손실, 어느 주소 접근하든지 엑세스 시간 동일
           - DRAM(Dynamic Random Access Memory), SRAM(Static Random Access Memory)로 나뉨
         - ROM(Read Only Memory): 비 휘발성 메모리
           - 전원 공급 중단되도 손실x, 컴퓨터를 처음 킬 때 구동하기 위한 BIOS같은 프로그램 적재
           - MASK ROM: 저장 데이터를 변경x, PROM(Programmable ROM): 1회 수정 가능, EPROM(Erasable PROM): 수정 가능한 ROM
      3. 입출력장치
         - 입력장치: 키모드, 마우스, 카메라, 스캐너, 터치스크린, 바코드 등
         - 출력장치: 모니터, 프린트
      4. 보조기억장치
         - 보조기억장치는 속도는 느리나 요량이 크고 저렴
         - 데이터 저장, 메모리 부족시 스왑 영역, 운영체제가 저장되어 있음
         - 하드디스크, SSD(Solid State Drive), CD-ROM, DVD, BD(Blu-ray Disc) 등

2. 리눅스 설치를 위한 하드웨어 요구사항
   1. CPU
      - 리눅스는 CPU에서 제공하는 어셈블리 언어와 쉽게 이식 가능한 C언어로 개발이 진행
      - 따라서 CPU 종속 특성 부분만 어셈블리 언어로 구현, 나머지는 C로 구성
      - GNU C가 지원하는 CPU 환경이면 이론적으로 리눅스 구동 가능
      - 인텔 x86, x64, x86_64, AMD 계열은 구동 가능
      - SPARC, Alpha, PowerPC, ARM, MIPS 등 지원
      - 병렬성(parallelism)을 높여 CPU의 최대 성능을 높이기 위해 CPU의 코어의 개수를 고려
   2. 메인보드
      - 거의 대부분 메인보드 지원
   3. 메모리
      - 거의 모든 메모리 지원
      - 32bit CPU에서 4G 이상 메모리를 필요한 경우 PAE(Physical Address Extendsion) 기술 사용 극복
      - 64bit CPU에서는 CentOS 6 기준 64TB까지도 사용 가능
   4. 하드디스크
      - IDE, E-IDE, SCSI, S-ATA 등 대부분 인터페이스를 지원
      - 파티션 설정 및 스왑 설정 가능
      - 장치를 파일로 관리하는 특징, IDE or ATA 인터페이스 경우 /dev/hdX 파일과 매핑
      - S-ATA, USB, SSD< SCSI는 /dev/sdX 파일과 매핑
   5. 모니터와 그래픽 카드
      - 대부분 모니터와 그래픽 카드 지원
      - 시스템에 장착된 그래픽 카드 알아보는 명령어: `lspci | grep -I vga`
   6. LAN 카드
      - 대부분 LAN 카드 기본으로 제공, 다양한 규격을 지원, 무선랜 지원
      - 네트워크 설정이 안될 시 제조사의 웹사이트 방문하여 드라이브 제공 여부 확인
      - 네트워크 설정을 위해 IP주소, 넷마스크, 게이트웨이 주소, DNS 서버 주소 등을 기관 네트워크 관리자를 통해 확인
   7. 키보드 및 마우스
      - 대부분 키보드와 마우스 지원, PS/2, Serial, USB 지원

### 2-1-2. 하드웨어의 선택

1. RAID의 개요
   1. 하드의 고성능 구현과 신뢰성을 여러 개의 하드디스크를 구성하고 중복된 데이터를 나눠서 저장
   2. 복수 배열 독립 디스크(Redundant Array of Independent Disks)기술
   3. RAID 0은 고성능 구현, RAID 1은 무정지 구현, RAID 1+0은 혼합한 형태
   4. RAID 5, RAID 6은 고성능과 무정지 추구
   5. 하나의 RAID 운영체제에서 논리적으로 하나의 하드디스크로 인식
   6. 스트라이핑 기술은 디스크 성능 향상, 라운드 로빈 방식으로 기록하는 기술
   7. 미러링 기술은 무정지를 위한 핵심 기술, 에러 발생 시 보호

2. RAID의 종류
   1. RAID-0
      - 데이터를 여러 디스크에 걸쳐 저장(스트라이핑 기술) 적용, 분산 저장
      - 저장시 동시에 여러 디스크에 쓰기 가능, 처리속도가 빠름
      - 디스크 오류시 복구 불가
   2. RAID-1
      - 패리티나 스트라이핑 없이 미러링 기술 사용, 데이터 두 개의 디스크에 동시 기록
      - 동시에 읽어들여 읽기 속도 향상, 쓰기 향상x, 효율성50%, 디스크 오류시 데이터 복구 가능
   3. RAID-2
      - bit 레벨의 스트라이핑 기술 적용, 최소 3개의 디스크에 분산 저장
      - 오류 정정 부호(ECC)를 기록하는 전용 하드디스크 이용
      - 오류 복구가 가능하지만 연산이 필요해 입출력 속도 저하
   4. RAID-3
      - byte 수준의 스트라이핑을 통해 데이터 분산 저장
      - 읽거나 쓸 때 각 디스크 동시 접근 가능, 순차 쓰기, 순차적 읽기 우수
      - 패리티 제공, 오류 체크 및 복구 가능
   5. RAID-4
      - block 레벨의 스트라이핑 제공, 데이터 분산 저장, 패리티 이용
      - 블록단위로 데이터 저장되 단일 디스크에서 데이터를 읽어 들일 수 있고 여러 디스크에서 동시에 읽기 가능
      - 데이터를 쓸 때 마다 패리티 디스크 접근, 쓰기 성능 저하
   6. RAID-5
      - RAID-4 와 같이 블록 수준 스트라이핑 저장, 패리티도 모든 디스크에 나눠 저장
      - 성능이 RAID0 보다 부족하지만 성능, 안정성, 요량 모두 우수
      - 현장에서 많이 사용
   7. RAID-6
      - RAID-5와 유사한 구성, 2차 패리티 구성 포함
      - 2개의 디스크 오류에 대처 가능
   8. RAID 0 + 1
      - 디스크 2개를 스트라이핑 후 미러링 적용
   9. RAID 1 + 0
      - 미러링 적용 후 스트라이핑, RAID 1보다 높은 성능 but 비쌈
   10. RAID 5 + 3
       - RAID-3 방식에 스트라이프 어레이 구성, 높은 성능 but 비쌈

3. 디스크 인터페이스
   1. IDE
      - 가장 오래된 규격, 40핀 병렬 인터페이스
      - PATA(Parallel Advanced Technology Attachment) 라고도 불림, 병렬 전송 강조
      - IDE 보다 성능이 향상 E-IDE(Enhanced IDE)가 있으며 133.3MB/s 속도로 전송
   2. S-ATA
      - IDE 성능 한계 극복, 직렬로 데이터 전단
      - SATA1 150MB/s, SATA2 300MB/s, SATA3 5Gb/s
      - SATA2는 허브를 이용해 하나의 포트에 여러 개 하드디스크 연결 가능
   3. SCSI(Small Computer System Interface)
      - 고성능, 안정성, 신뢰성 중시하는 워크스테이션 및 서버에 주로 사용
      - 10000RPM 고성능 하드 장착 최적 성능, 병령 방식 성능의 한계
   4. SAS(Serial Attached SCSI)
      - SCSI 한계 극복, 시리얼 방식 디스크 인터페이스
      - SCSI의 안성정, 확장성, 신뢰성을 이어함, 시리얼 전송을 통해 속도 향상

4. LVM(Logical Volume Manger)
   1. LVM 개요
      - 블록 디바이스를 유연하게 관리하기 위해 여러 블록디바이스를 가상의 Logical Volume에 매핑, 스토리지를 관리하는 커널 기능
      - 기존 블록디바이스에 직접 I/O를 수행, LVM은 LVM이 매핑한 Logical Volume에 I/O를 수행
      - 유연한 용량, 크기 조절 가능한 스토리지 풀, 온라인 데이터 재배치, 디스크 스트라이핑, 미러 볼륨, 볼륨 스냅샷
   2. LVM 구성도
      1. Volum Group(VG01)
         1. Physical Volume(/dev/sda3): 일부를 Logical Volume(/var)에 매치, 남은걸 Logical Volume(/home)에 매치
         2. Pyshical Volume(/dev/sdb2): 일부를 Logical Volume(/home)에 매치, 남은걸 남겨둠
         3. Logical Volume(/var)
         4. Logical Volume(/home)
   3. LVM 구성요소
      1. PV(Physical Volume): 기존 블록 디스크를 LVM에서 사용할 수 있도록 변환한 볼륨 형식
      2. PE(Physical Extent): PE라 불리는 일정 크기의 블록들이 모여 PV, 기본 크기는 4MB
      3. VG(Volume Group): 여러 PV를 묶어 VG로 토합 가능, VG에 LV 할당 가능 
      4. LV(Logical Volume): VG에서 필요한 만큼 할당하여 만들어지는 공간, 사용자는 LV통해 하드에 접근
      5. LE(Logical Extent): LV를 구성하는 일정 크기의 블록, 기본 키그는 4MB

## 2-2. 리눅스의 구조

### 2-2-1. 부트 매니저

1. 부트 매니저의 개요
   1. 정의
      - 부트 매니저(Boot Manger)는 보조기억장치에 위치한 운영체제를 주기억장치로 로드하기 위한 프로그램
      - 부트 로더(Boot Roader) 라고도 함
   2. 동작원리
      - 시스템이 켜지면 BIIOS는 디스크의 첫 번째 섹터(0번 섹터)인 부트 섹터에서 512바이트 MBR(Master Boot Record)를 읽음
      - IPL은 파티션 테이블을 검사, 부트 로더의 나머지 코드의 위치를 알아내 실행
      - 리눅스의 대표적인 부트 매니저 프로그램은 LILO(Linux Loader)와 GRUB(Grand Unified BootLoader)

2. 부트 매니저 종류
   1. LILO(Linux Loader)
      - 모든 리눅스 배포판의 표준, 가장 오래된 부트 로더, 지속적인 커뮤니티의 지원
      - 1,024개의 실린더 인식 한계가 있던 부분도 개선
      - LILO 설정: `/etc/lilo.conf`
      - 설정 파일 변경 후 LILO stage 1 부트 로더를 MBR로 다시 쓰기 위해 `lilo` 명령을 반드시 수행
   2. GRUB(Grand Unified Boot Loader)
      - GUN 프로젝트에서 만든 부트 로더
      - LILO와 달리 대화형 명령어 인터페이스를 제공, 네트워크 부팅 제공
      - 배포판마다 설정 파일명이 다를 수 있지만 CentOS 6의 경우 `/boot/grub/grub.conf` 파일 존재
      - GRUB은 설정 파일 변경 후 특별한 조치 없이 적용

3. GRUB 사용해보기
   1. GRUB 초기화면
      - 부팅 시 아무키나 누르면 화면 진입
      - GRUB로 부팅할 수 있는 운영체제 목록 확인 가능
      - `e`: 해당 목록의 부트 로더 설정 변경
      - `a`: 부트 로더 설정 중 커널에 인자를 수정
      - `c`: 명령 줄 모드로 진입
   2. GRUB 편집화면
      - `e`: 편집화면 진입
      - /boot/grub/grub.conf에 설정된 root, kernel, initrd 설정을 임시로 변경 가능

4. GRUB 환경설정 파일
   1. boot: 부팅 디스크 설정, 디스크가 하나일 시 주석 표시
   2. default: 아무 선택 하지 않을 시 부팅할 운영체제의 순서
   3. timeout: 최대 시간, 시간 만료시 default 설정된 운영체제 로드
   4. splashimage: GRUB 화면의 배경 이미지
   5. title: GRUB 부딩 메뉴 표시되는 이름
   6. root: 루트 디바이스 설정, x는 하드디스크 파일명, y는 부트 파이션 번호
   7. kernel: 부딩에 사용할 커널 이미지 파일 경로 지정, 매개변수 설정, root 파티션 위치 설정
   8. rootnoverify: root와 유사, 해당 파티션 마운트x, NTFS 파이션과 같이 GUB이 인식할 수 없는 파티션을 root 디바이스로 지정할 때 사용

### 2-2-2. 주요 디렉터리 구조

1. 리눅스 파일시스템 표준(FHS: File system Hierarchy Standard)
   1. 파일시스템 표준은 BSD 파일시스템 계층 구조 기반, 디렉터리 구조 표준
   2. 리눅스 재단(HP, 레드햇, IBM, Dell 등)이 관리, 최신 버전 2.3(2004.01.29)

2. 리눅스의 주요 디렉터리
   1. `/`: 리눅스 파일시스템의 최상위 디렉터리
   2. `/bin/`: 모든 사용자가 사용할 수 있는 명령어(ls, cp, mkdir 등)
   3. `/boot/`: 커널 파일, initrd 등 부팅이 필요한 파일(grub 파일 등)
   4. `/dev/`: 디바이스 파일(하드, CPU, 네트워크 등)
   5. `/etc/`: 시스템 환경 설정 파일, 시스템초기화시 수행되는 여러 스크립트 파일(Editable Text Configuration, Extended Tool Chest)
   6. `/home/`: 로그인한 사용자 전용 홈 디렉터리
   7. `/lib/`: 시스템에 설치된 각종 라이브러리가저장된 디렉터리, `/lib/modules`에는 설치된 커널 모듈이 위치
   8. `/media/`: 
   9. `/mnt/`: 
   10. `/opt/`: 
   11. `/proc/`: 
   12. `/root/`: 
   13. `/sbin/`: 
   14. `/tmp/`: 
   15. `/usr/`: 
   16. `/usr/bin/`: 
   17. `/usr/include/`: 
   18. `/usr/lib/`: 
   19. `/usr/sbin/`: 
   20. `/usr/src/`: 
   21. `/usr/X11R6/`: 
   22. `/var/`: 


### 2-2-3. 부팅과 셧다운

1. 부팅의 개요
   1. 부팅: 컴퓨터가 켜지고 사용자가 시스템을 사용할 수 있도록 운영체제를 기동하는 절차
   2. 부팅 위해 BIOS, MBR 부트 로더 실행, 부트 로더는 지정 위치의 커널을 메모리에 읽어 드린 후 프로세스 실행
   3. 사용자 지정 실행 레벨에 따라 지정된 스크립트 수행, 운영체제의 나머지 초기화

2. 부팅의 상세 절차
   1. 단계: 시스템 시작 및 하드웨어 초기화 -> 부트 로더 1단계 -> 부트 로더 2단계 -> 커널 -> INT 프로세스 -> 사용자 프롬프트
   2. 시스템 시작 및 하드웨어 초기화
      - 가장 먼저 ROM 영역의 저장된 프로그램을 실행
      - POST(Power On Self Test) 기능 실행: 그래픽 카드 체크, 메인보드, 주변 장치 체크, 과정 모니터에 출력
   3. 부트 로더 1단계
      - MBR: 하드디스크의 0번 섹터, 운영체제 로드를 위한 부트 로더가 위치
      - 0번 섹터: 512byte로 크기가 한정, 실제 부트 로더가 위치한 디스크로 점프하는 역할까지 수행
   4. 부트 로더 2단계
      - 부트로더 실행, LILO, GRUB 등
      - GRUB은 MBR 이후 약 30kilobytes 내에 연속된 주소에 위치, `grub.conf` 설정에 따라 선택할 운영체제 목록을 표시
      - 사용자가 운영체제를 선택 시 커널을 메모리에 로드, 커널에게 제어권 전달
   5. 커널
      - 하드, 소프트웨어 관장하는 핵심 모듈
      - 한번 메모리(RAM)에 로드되면 시스템 리부트, 종료할 때까지 상주
      - GRUB으로부터 제어권을 이어받은 커널은 INIT 프로세스를 실행
   6. INT 프로세스
      - INIT 프로세스: 초기화 작업을 다음 단계로 수행
      - `/etc/rc.d/rc.sysinit` 스크립트 실행
      - 위 스크립트에서는 시스템의 프로퍼티, 하드웨어, 디스플레이, SELinux, 커널, 모듈, 파일시스템 마운트 등을 체크
      - `/etc/inittab` 파일을 읽어 실행레벨 확인, 그에 맞는 스크립트 실행
      - 예를 들어 실행레벨이 5인 경우 `/etc/rc5.d` 디렉터리에 위치한 스크립트 실행
      - 실행레벨 관련 스크립트 수행 후, `etc/rc.local`에 정의된 프로세스를 실행
      - 0: 시스템 종료
      - 1: 단일 사용자 모드(시스템 복원모드, Root 권한을 셸로 얻음)
      - 2: 다중 사용자 모드(네트워크 제공x)
      - 3: 다중 사용자 모드(네트워크 제공o)
      - 4: 현재 사용되고 있지 않은 모드
      - 5: X 윈도우 사용하는 다중 사용자 모드
      - 6: 시스템 재부팅시 사용하는 실행레벨
   7. 사용자 프롬프트(user prompt)
      - 모든 초기화 완료시 실행레벨에 따라 다르지만 X-Window나 terminal을 통해 입력을 받을 준비 완료

3. 로그인과 로그아웃
   1. 로그인
   2. 로그아웃

4. 로그인/로그아웃 관련 문제 해결
   1. Root 패스워드 분실 대응하기
   2. GRUB 패스워드 분실 대응하기

5. 시스템 종료
   1. X 윈도우 환경에서 셧다운하기
   2. 시스템 종료 방법
   3. 시스테을 재부팅하는 방법
   4. 예약된 시간에 시스템을 종료하거나 재시작(reboot)하는 방법

### 2-2-4. 파일시스템의 이해

1. 파일시스템의 개요
2. 리눅스파일시스템의 구조
3. 리눅스 로컬 파일시스템(Local Filesystems)
4. 클러스터 파일시스템(Clustered Filesystems)
5. 기타 리눅스 파일시스템
